# 18. `unique_ptr`, управление памятью, move
* ## Ручное управление памятью: `new`, `delete`, `new[]`, `delete[]`, когда что использовать.
Это `Dinamic storage duration`, `new` выделяет память, обычно на куче, и возвращает указатель на свежесозданный объект, который мы обязуемся удалить с помощью оператора `delete`. (иначе произойдёт утечка памяти). Квадратные скобки выделяют массив элементов, которые будут лежать подряд в памяти. В скобках нужно указать количество объектов в массиве. При этом при удалении этого делать не нужно.  
```C++
struct Foo{

};
int main() {
    Foo *f = new Foo;
    Foo *arr = new Foo[1000];
    delete f;
    delete[] arr; // no memory leak
}
```
  * ### Не было: разница между `new int;` и `new int();`
  * ### Утечка памяти: UB ли, какие последствия, как ловить, как читать вывод sanitizer и Valgrind с примерами.  
  Утечка памяти это не уб, программа спокойна работает, просто появляется всё новая и новая выделенная память, что может вызвать проблемы. Например, если мы сервер вк, то утечки памяти лучше не допускать, иначи со временем памят на сервере кончится.  
  
* ## Отличия `unique_ptr` от обычного указателя, когда что использовать
* ## Создание `unique_ptr`: какие есть конструкторы, что делает `make_unique`
  * ### Проблема с `make_unique` и приватными конструкторами
  * ### Решения: неработающее с друзьями, работающее с фабричной статической функцией
* ## Невозможность копирования
* ## Синтаксис перемещения: в параметры функции, из функции, в/из других переменных (включая поля: `13-211208/02-move-objects/03-move-to-field`), в/из контейнеров
  * ### Когда (не) надо писать `std::move`
* ## `move` как оптимизация для копируемых объектов, автоматическая поддержка `move` у пользовательских структур
  * ### moved-from состояние у объектов

Тесно связано с: функции (как передавать параметры), жизнь объектов.
